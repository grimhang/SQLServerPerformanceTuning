---
sort: 4
---

# CPU Performance Analysis

CPU 병목현상을 알아내는것은 매우 힘든 과정이다. 또한 쉽게 증설 가능한 메모리, 디스크와 달리 CPU는 시스템과 통합되어 출시되기 때문에 CPU 증설은 신규 머신을 사야지만 가능한 경우가 대부분이다. 

* CPU 수치 수집 방법

## 4.1 CPU 병목 분석    
디스크 속도는 메모리와 CPU에 비해 상대적으로 매우 느리다. 디스크 자원 경합은 SQL Server의 성능을 심각하게 다운 시킬수 있기에 디스크쪽 병목을 분석하고 해결하면 SQL Server의 성능을 급격히 향상 시킬수 있다.

### CPU 분석 카운터

```
Object(Instance)            Counter                 Description                           Value
----------------------      --------------          ---------------------------------     ---------------------------------------
Processor(_Total)           % Processor Time        프로세서 사용 %                       평균 80% 이하여야 하지만 베이스라인 참고
                            % Privileged Time       특권 모드에서 소요된 프로세서 %       평균 10% 이하여야 하지만 베이스라인 참고
System                      Processor Queue Length  프로세서 작업 대기 개수               평균   2 이하여야 하지만 베이스라인 참고
                            Context Switches/sec    프로세서에서 쓰레드간 전환 비율       평균 5,000 이하여야 하지만 베이스라인 참고
SQL Server:SQL Statistics   Batch Requests/sec      초당 들어온 SQL 개수                  베이스라인 참고
                            SQL Compilations/sec    초당 SQL 컴파일 횟수                  베이스라인 참고
                            SQL Recompilations/sec  초당 SQL 재컴파일 횟수Disk Bytes/sec 
```

### * % Processor Time
지속적으로 80% 이상이면 병목으로 판단된다. 이때 진짜 CPU사용량이 많아서 이 값이 높은지 아니면 메모리, 디스크, 네트워크 같은 다른 자원의 문제때문인지 판단하는 것이 중요하다. 이 수치가 지속적으로 높고 디스크와 네트워크가 낮을 경우가 진짜 CPU 과다 사용인데 이런 경우 프로세서의 스트레스를 줄여야 하며 그렇지 않다면 해당 자원을 먼저 해결하는 것이 옳바른 순서이다.  
예를 들면 % Processor Time이 85%인 상태에서 I/O쪽에서 과도한 디스크 액세스가 있다면 CPU는 디스크 활동을 관리하는데 대부분의 자원을 소모하는 것일수 있다. 이는 % Privileged Time 카운터에 반영된다. 이런 경우라면 디스크 병목을 먼저 해결하는것이 맞고 또한 디스크 병목은 메모리 병목 때문에 발생할수도 있기 때문에 진짜 범인을 찾는 것은 매우 어려운 문제이다.

이 값들은 단순한 초기 제안 값일 뿐이고 때로는 각자만의 타당한 이유로 이런 수치에 동의하지 않을 수 있기 때문에 이 수치를 권장사항이 아닌 단순한 시작점으로 생각하여 진행해야 한다.
 
모든 프로세서의 Total로 프로세서 시간을 추적하거나 특정 프로세서에 대한 사용률을 개별적으로 추적 할 수 있다. 만약 4개의 프로세서를 가진 컴퓨터인 경우 3개만 SQL Server에 할당되었다면 각각의 프로세서를 정확히 분리해서 데이터를 얻어야 한다. 하나의 프로세서가 최대 값을 냈지만 다른 프로세서에는 부하가 거의 없을 수 있다. 평균은 때때로 실제수치를 정확히 반영 못하기에 개략적 지표로서만 사용하고 개별 값들을 시스템의 실제 부하 및 처리 수치로 사용한다. 

가상화 된 환경에서는 CPU도 가상화되어지기 때문에 표시되는 내용이 정확하지 않을 수 있다. 예를 들어 VMware 시스템에서 VMware Tools를 설치하면 VM Processor 카운터에서 호스트 컴퓨터의 프로세서 사용량을 확인할 수 있고 이 측정 값을 사용하면 OS에 표시되는 CPU 사용량이 호스팅 시스템에 반영되는지 아니면 실제로 가상 CPU를 최대로 사용하는 지 여부를 알 수 있다. 다른 말로 \Hyper-V Hypervisor Logical Processor(_Total)\% Total Run Time 이 같은 수치.
사용중인 하이퍼바이저에 따라 다른 측정 값이 있다.

### * % Privileged Time
윈도우는 유저모드와 특권모드(커널모드)라는 두 가지 모드중 하나에서 실행된다. 디스크 액세스와 같은 시스템 레벨활동은 특권모드에서 실행된다. 전용 SQL Server 머신에서 이 수치가 20에서 25 % 이상이라면 아마도 많은 외부 작업이 있을 수 있다. 원인은 I/O, 암호화 서비스 같은 필터 드라이버 또는 오래된 드라이버들 일 수 있다. 전용 SQL Server에서 이 카운터는 많아야 5에서 10%여야 하지만 더 중요한 것은 평상시의 베이스라인 데이터와 비교하는 것이다.

### * Processor Queue Length
이 카운터는 프로세서 큐에 있는 쓰레드의 개수이다. 디스크쪽 카운터와 달리 Processor Queue Length는 실행 중인 쓰레드를 포함 하지 않는다. 보통의 낮은 CPU 사용률의 시스템에서는 이 카운터 수치가 0 또는 1이다.

계속해서 2보다 큰 값이라면 일반적으로 프로세스 정체를 나타낸다. 다중 프로세서이기 때문에 Processor Queue Length를 처리하는 스케줄러 수를 고려해야 할 수도 있다. 이 수치가 스케줄러의 수보다 두배 많은 경우 프로세서 병목을 표시할 수 있다. 일반적으로 1:1.  
높은 % Processor Time 카운터도 바쁜 CPU상황을 알려주지만 지속적으로 높은 Processor Queue Length는 보다 명확하게 알수 있는 지표이다. 권장수치를 초과하면 이는 일반적으로 현재 프로세서 수가 서비스 할 수있는 적절간 개수보다 실행 할 스레드가 더 많음을 나타낸다.

### * Context Switches/Sec
Context Switches/sec 카운터는 시스템의 모든 프로세서들이 한 쓰레드에서 다른 쓰레드로 전환하는 비율을 모니터링 한다. 컨텍스트 전환은 실행중인 스레드가 자발적으로 프로세서를 놔주거나 또는 우선 순위가 더 높은 준비 스레드가 선점하거나 또는 하위 시스템 서비스를 사용하기 위해 사용자 모드와 권한 모드 사이를 전환 할 때 발생한다. 컴퓨터의 모든 프로세서에서 실행중인 모든 스레드에 대한 Thread : Context Switches / sec의 합계이며 스위치 수로 측정됩니다. 높은 수치는 주로 CPU 속도에 의해 결정되므로 시간 경과에 따른 성능을 측정하고 이 수치를 베이스라인과 비교한다.







