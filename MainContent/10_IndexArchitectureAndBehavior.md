---
sort: 10
comments: true
---

# 인덱스 아키텍처와 동작

정확한 열의 정확한 인덱스는 쿼리 튜닝 시작의 기본이다. 누락되거나 잘못된 열에 만들어진 인덱스는 모든 성능 문제의 원인이 될 수 있다. 이러한 이유로 DBA뿐 아니라 모든 사람이 데이터베이스 디자인을 최적화하는 데 사용할 수 있는 다양한 인덱싱 기술을 이해하는 것이 매우 중요하다.

이번 장에서는 다음 내용을 포함한다.

    - 인덱스란 무엇인가?
    - 인덱스의 이점과 그에 따른 오버헤드
    - 인덱스 디자인시 일반적인 권장사항
    - 클러스터드와 넌클러스터드 인덱스 비교와 동작
    - 클러스터드와 넌클러스터드 인덱스 권장사항

## <font color='dodgerblue' size="6">9.1 인덱스란 무엇인가?</font>

디스크 I/O를 줄이는 가장 좋은 방법 중 하나는 인덱스를 사용하는 것이다. 인덱스는 SQL Server가 전체 테이블 스캔하지 않고도 데이터를 찾을 수 있게 한다. 데이터베이스의 인덱스는 책의 색인과 유사하다. 예를 들어 이 책에서 "테이블 스캔" 이라는 구문을 찾고 싶다고 가정해 보자. 종이 책의 경우 책 뒷면에 색인이 없으면 필요한 텍스트를 찾기 위해 책 전체를 정독해야 한다. 인덱스를 사용하면 원하는 정보가 저장된 위치를 빠른 시간안에 정확히 찾을 수 있다.

성능을 위해 데이터베이스 튜닝을 하는 경우 쿼리 구문에 사용된 여러 컬럼들에 인덱스를 만들게 된다. 예를 들면 아래의 쿼리는 Production스키마를 사용한다.
```sql
SELECT TOP 10
    p.ProductID,
    p.[Name],
    p.StandardCost,
    p.[Weight],
    ROW_NUMBER() OVER (ORDER BY p.Name DESC) AS RowNumber
FROM Production.Product p
ORDER BY p.Name DESC;
```

![쿼리저장소의저장되는정보](image/10/10_01_SampleProductTable.png)  

    그림 10-1 샘플 Production.Product 테이블

where 조건이 없는 풀 테이블 스캔을 하는 쿼리이다. StandardCost가 150보다 큰 제품들을 찾고자 WHERE 절을 이용해 필터를 추가한다면 인덱스 없이는 여전히 풀테이블스캔을 할것이다. 