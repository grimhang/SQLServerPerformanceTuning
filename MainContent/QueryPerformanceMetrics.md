---
sort: 8
---

# Query 성능 수집
느린 SQL Server 성능의 일반적인 원인은 과도한 데이터베이스 응용 프로그램 워크로드, 즉 쿼리 자체의 특징과 양이다. 그러기에, 시스템 병목의 원인을 분석하기 위해서는 데이터베이스 어플리케이션 워크로드를 조사하여 시스템 리소스에 가장 큰 스트레스를 일으키는 SQL 쿼리를 식별하는 것이 중요하다. 
이를 하기 위해 **확장 이벤트**와 **다른 매니지먼트 스튜디오 툴**을 이용할 수 있다.

이번 장에서는 다음과 같은 내용을 설명한다.

    * 확장 이벤트 기본
    * 확장 이벤트를 이용하여 SQL Server 워크로드를 분석하고 비용이 많이 소모되는 SQL 식별하는 방법
    * 동적관리오브젝트(DMO)로 쿼리 성능 추적하는 방법

## <font color='dodgerblue' size="6">1) 확장 이벤트(XE)</font>
확장이벤트는 SQL Server 2008에서 처음 소개되었지만 GUI는 없었고 세팅하기가 매우 복잡핬다. 성능 측정치를 캡처하기 위해 많이 사용되지 않았ㄷ. 2012가 되서야 확장이벤트를 관리하기 위한 GUI가 소개되었고 성능수치를 수집하기 위한 우선순위 옵션이 되었다. 이전에 프로필러와 같은 툴로 수집하는 가장 선호하는 방법이었던 추적 이벤트 기능은 점점 비추천 되었고 더이상 개발되지도 않는다. 몇년동안 어떤 추적 이벤트 기능도 추가되지 않았다. 프로필러는 운영서버에서 적절하지 않게 사용될 경우 성능상 오버헤드가 발생할 수 있다. 결과적으로 이 책의 예제들은 주로 확장 이벤트를 사용할 것이며 두번째로는 쿼리 저장소를 사용할 것이다.

확장 이벤트는 다음과 같은 기능이 있다.

    * SQL Server 쿼리를 그래픽UI로 모니터링
    * 백그라운드에서 쿼리 정보 수집
    * 성능 분석
    * 데드락 같은 문제 진단
    * Transact-SQL(T-SQL) 디버깅

SQL Server 인스턴스에서 수행되는 여러 종류의 활동을 캡처하기 위해서도 확장 이벤트를 사용할 수 있다. 그래픽UI나 쿼리 명령어를 이용해 설정 할 수 있다. 확장 이벤트 세션을 만드는 가장 효과적인 방법은 T-SQL 명령어를 이용하는 것이다. 그러나 GUI를 통해 세션에 대해 배워나가는 것도 좋은 선택지이다.


- ### a. 확장 이벤트 세션
SSMS GUI안에 내장되어 있는 확장 이벤트를 발견 할 것이다. 오브젝트 탐색기를 통해 찾아가다 보면 확장 이벤트 폴더를 찾을 수 있다. 거기에서 이미 만들어져 있는 시스템 세션들을 볼 수 있다. 새로운 세션을 만들기 위해서는 세션 폴더를 오른쪽 마우스 클릭하고 새 세션을 누른다. 세션을 설정하는 데 사용할 수 있는 마법사가 있지만 일반 GUI가 하지 않는 작업은 수행하지 않으며 일반 GUI는 사용하기 쉽습니다. 새 창이 열리며 일반 설정으로 시작한다.

    ![XE시작화면](image/08/XEWin01_StartWin.png){: width="80%"}  

    이 화면에서 세션이름을 지정해 준다. 나중에 명확하게 알 수 있게 명확한 이름을 지정하는 것을 권고한다. 또한 템플릿을 사용할수 있다. 프로필러를 사용할 때와 같이 미리 설정된 템플릿을 이용하면 최소의 노력으로 만들 수 있다.  
    "쿼리 실행" 카테고리안에 쿼리 튜닝과 연관된 5개의 템플릿이 있고 다음과 같다

        a. 쿼리 일괄 처리 샘플링 : 활성 세션의 20%만 쿼리와 프로시저 수집.
        b. 쿼리 일괄 처리 추적   : 모든 쿼리와 프로시저 수집하기에 주의 요망
        c. 쿼리 정보 샘플링      : 활성세션의 20%의 쿼리와 프로시저의 모든 스테이트먼트 수집.
                                  sp_statement_completed, sql_statement_completed, module_end가 추가됨
        d. 쿼리 정보 추적        : 모든 쿼리와 프로시저의 스테이트먼트 수집.
                                  역시 sp_statement_completed, sql_statement_completed, module_end가 추가되기에 주의 요망.
                                  데이터 스토리지를 ringbuffer로 해서 조금 다행이지만 서버 뻗을수도..
        f. 쿼리 대기 통계        : 모든 활성 세션의 20%에 해당하는 쿼리, 프로시저의 스테이트먼트에 대한 대기 통계 수집.

    게다가 프로필러에서 자주 사용한 항목들을 가져온 템플릿들도 있다. 또한 2017에서 소개되었으며 최소의 노력으로 빠르게 쿼리성능을 조사하는 추가적인 하나의 방법이 있다. 개체 탐색기의 아래부분에 XEvent 프로파일러라는 새로운 폴더이다. 폴더를 확장해보면 프로필러에서 주로 보았던 것을 비슷하게 쿼리 모니터링을 정의한 두개의 확장 이벤트 세션을 발견할 수 있다. 이번 장 뒤에서 라이브 데이터 감시라는 기능을 통해 함께 설명한다. 이것을 실행하는 대신 템플릿을 건너뛰고 XE 프로파일러 나만의 이벤트를 세팅하기 위하여 리포트 해주기에 완료된 방법을 볼 수 있다. 

    ```note
    꽁짜거나 위험이 없는 일은 세상에 없다. 확장이벤트는 예전 프로파일러나 추적이벤트보다 시스템 정보를 수집하는 더 효과적인 메카니즘이다. 하자만 비용이나 위험이 없을 수는 없다. 이 장의 뒤에서 좀더 자세히 설명하겠지만 몇몇 전역 필드에 의존하여 하나의 충격을 볼수 있을지도 모른다. 운영 시스템에 네거티브 임팩트가 없는지 확인하기 위해 충분히 조심하여 미리 연습하자. 쿼리 저장소는 더 적은 임팩트가 있게 많은 정보를 제공해 주고 DMO들로 보다 적은 임팩트를 얻을 수 있다. 이런 대체 방법은 몇가지 상황에서 작업할수 있다.
    ```

    세션만들기 첫번째 창에서 이름을 적는 이외에 몇가지 다른 옵션들이 있다. 서버 시작할때 자동으로 시작되도록 결정할 수 있다. 오래동안 성능 항목들을 수집하면 할수록 저장되는 수집 데이터 크기도 증가한다. 생성과 동시에 시작과 라이브 데이터 감시를 바로 할수도 있다. 마지막으로 이벤트 관계 추적을 설정할 수 있다. 이에 대한 자세한 설명은 뒤에서 한다.

    새 세션 창은 이미 마법사와 거의 근접하다. 다음 버튼을 누르면 추적하기 원하는 이벤트를 추가하는 창이 열린다. 이벤트 라이브러리에 원하는 이벤트의 일부 단어를 쳐도 like 검색이 되어 편리하다.
    ![XE이벤트추가](image/08/XEWin02_AddEvent.png){: width="85%"}  

    여기에는 이벤트 대상, 이벤트 패키지, 이벤트 세션등으로 구성되어 있는 이벤트 아키텍처가 존재한다. 하지만 GUI사용은 그런 세부사항에 대해 걱정하지 않게 해준다. 뒷부분에서 세션을 스크립팅하는 방법을 보여줄때 일부 아키텍처 부분들도 같이 한다.

    성능 분석을 위해서, SQL Server에서 수행되어지는 다양한 활동들의 리소스 스트레스의 레벨을 판단하는데 도움을 주는 이벤트들에 주로 관심을 가질 것이다. 리소스 스트레스에 의해 다음과 같은 다양한 것들을 의미한다.

        * 어떤 종류의 CPU 사용이 T-SQL 활동에 포함되나?
        * 얼마나 많은 메모리가 사용되나?
        * 얼마나 많은 I/O가 포함되나?
        * 얼마나 오래 SQL이 실행되나?
        * 얼마나 빈번하게 특정 쿼리가 실행되나?
        * 어떤 종류의 에러가 경고가 쿼리에서 발생하는지?

    우리는 이벤트의 종료후에 SQL에 의한 리소스 스트레스를 계산할 수 있다. 그래서 성능 분석에 사용하는 주된 이벤트들은 SQL 활동의 완료를 대표하는 것이다. 리스트는 다음과 같다.

    ```
    Event Category  Event                       설명
    --------------- --------------------------  --------------------------------------
    Execution       rpc_completed               원격 프로시저 호출 완료시. 주로 sp완료
                    sp_statement_completed      sp안의 sql 구문 1개 종료시
                    sql_batch_completed         T-SQL 일반 쿼리가 종료시
                    sql_statement_completed     T-SQL 일반 쿼리의 1개 sql 구문 종료시
    ```

    RPC 이벤트는 OLEDB명령어 통하여 원격 프로시저 호출(Remote Procedure Call) 메카니즘을 사용할때 발생한다. 데이터베이스 어플리케이션이 T-SQL의 Execute 구문을 통해 sp를 실행시킬 경우에는 RPC보다는 SQL 배치로 해석된다. 

    T-SQL 배치는 SQL서버에 함께 보내지는 SQL쿼리들의 묶음이며 보통 GO 구문으로 나누어진다. GO 구문은 T-SQL 구문이 아니다. 대신에 GO구문으로 sqlcmd 유틸리티를 사용할때 1개의 배치를 인식하도록 한다. 또한 ssms에서도 사용되며 1개의 단일 배치로 묶는다. 1개의 배치에 있는 각각의 SQL 쿼리는 T-SQL 구문(스테이트먼트)라고 부른다. 그러기에 T-SQL 배치는 1개 이상의 T-SQL 구문으로 구성된다. 구문 또는 T-SQL 구문은 각각 별개의 명령어이다. sp_statement_com;eted와 sql_statement_completed 이벤트는 쿼리안의 개별 스테이트먼트가 많으면 많을 수록 더 비싼 연산 이 될수 있다. 
    XEvent 세션 활동은 쿼리를 수집하는 행위와 수집완료한 쿼리 정보를 별도의 저장소(주로 로컬 하드디스크)에 저장하는 두가지 측면을 고려해야 한다. 프로시저안에 여러개의 스테이트먼트가 있고 그 스테이트먼트가 또 다른 프로시저를 호출하는 등의 경우가 있는 경우에는 시스템에서 분명하게 인식할 수 있을정도의 로드가 된다. 스테이트먼트를 완전하게 수집하는 충격은 크기와 수집하려하는 스테이트먼트들의 숫자에 의존한다. 스테이트먼트 완료 이벤트는 특히 운영 시스템에서는 신중하게 수집해야 한다. 그러기에 이런 이벤트들에서 반환을 제한하기 위해 필터를 사용해야 한다. 필터는 뒤에서 다룬다.

    세션에 이벤트를 추가하기 위해서 이벤트 라이브러리를 찾는다. 간단하다. 원하는 이벤트를 치면 like 검색이 되어 나타난다. 위의 그림에서 sql_batch를 치니까 결과가 여러개 나왔다. 원하는 이벤트를 더블클릭하거나 오른쪽 화살표를 누르면 오른쪽의 "선택한 이벤트" 영역으로 이동한다. 역시나 제거할 경우에도 더블클릭하거나 왼쪽 화살표를 누르면 "선택한 이벤트" 영역에서 제거된다. 

    표에 있는 이벤트 리스트들이 성능 수집할때 가장 많이 사용하는 이벤트들이지만 다른 측정항목을 수집하기 위해서 다양한 이벤트들을 추가할 수 있다. 예를 들면 1장에서 다루었던 반복되는 sp 재컴파일을 추적하기 위해 sql_statement_recompile을 추가하는 것처럼. 이벤트 라이브러리는 데이터베이스 워크로드와 같은 기타 성능 관련 이슈들을 수집하기 위한 추가적인 이벤트드ㅡㅇㄹ 포함한다. 아래 표는 이런 종류의 몇가지 이벤트들이다.

    ```
    Event Category  Event                           설명
    --------------  ------------------------------  ----------------------------------
    Session         login                           SQL Server에 연결 또는 연결종료할때 발생
                    logout  
                    exisiting_connection            세션이벤트를 만들기 전에 이미 만들어져있는 연결 정보
    Erros           attention   
                    error_reported                  에러가 보고될때 발생
                    execution_warning               명령문에 대한 메모리 할당 대기가 1초이상 지속되거나 또는 메모리 할당이 실패하거나
                    hash_warning                    해시 연산에서 충분하지 않은 메모리 발생시. 어떤 연산이 에러 났는지 이해하기 위해서는
                                                    실행계획 캡처와 함께 수행해야
    Warning         missing_column_statistics       옵티마이저가 프로세싱 전략을 결정하기 위해 필요한 컬럼의 통계정보가 없을경우
                    missing_join_predicate          쿼리가 두개의 테이블간에 조인 예측전략 없이 실행되는 경우
                    sort_warning                    SELECT와 같은 쿼리에서 수행되는 정렬 연산할때 메모리가 부족할 경우
    Lock            lock_deadlock                   deadlock 희생이 발생할때
                    lock_deadlock_chain             데드락을 만드는 쿼리의체이의 추적을 보여준다.
                    lock_timeout                    SET LOCK_TIMEOUT (ms)가 세팅되었을때 그 시간 초과하는 경우
    Execution       sql_statement_recompile         쿼리 명령문의 실행계획이 재컴파일되는 경우.          
                                                    1. 존재하지 않거나
                                                    2. 강제로 재컴파일
                                                    3. 이미 있지만 사용되지 않아서
                                                    배치레벨이 아닌 명령문 레벨. ad-hoc쿼리, sp, 프리페어드 sql 무도 상관없이
                    rpc_starting                    sp 실행시. sp가 실행은 했지만 오래 걸려 종료되지 않았을 경우 사용.
                    query_post_comilation_showplan  SQL 명령문이 컴파일된 후 실행계획 보여줌
                    query_post_execution_showplan   SQL 명령문이 실행된 후 실행계획 보여줌. 실행통계 포함.
                                                    주의) 이 이벤트는 높은 비용이 될 수 있기에 적절한 필터를 설정해서 짧은기간 측정해야 한다.
    Transactions    sql_transaction                 데이터베이스 트랜잭션에 대한 정보 제공. 트랜잭션 시작, 종료, 롤백할때 정보 포함.
    ```

- ### b. 전역 필드

    선택한 이벤트를 더블클릭하면 원하는 필드를 선택할 수 있다. 그 중 전역필드는 모든 이벤트에서 공통적으로 포함하는 속성을 선택하는 것이다.
    ![XE이벤트추가](image/08/XEWin03_GlobalFiled.png){: width="85%"}  

    T-SQL에서 동작(액션)으로 불렸던 전역 필드는 이벤트에 관련된 사용자, 이벤트의 실행계획, 이벤트의 추가 리소스 비용 그리고 이벤트의 소스 같은 이벤트의 여러가지 속성 항목들이다. 이것들은 이벤트와 함께 수집되는 정보의 조각들이다. 그것들은 이벤트 수집작업에 오버헤드가 추가된다. 각각의 이벤트는 수집하려는 데이터들 셋이지만 더 많은 항목을 추가할 수 있는 선택의 기로에 있다. 이에 대해 뒤에서 보다 자세히 설명할 것이다. 내가 작업할때는 대부분의 시간동안 이 오버헤드를 피할 수 있게 하는데 보낸다. 하지만 때때로 수집하고 싶은 정보들이 여기에 있다.

    동작을 추가하기 위해서 위의 그림처럼 전역 필드에서 제공하는 리스트들중 선택하면 된다. 
    기본적으로 선택하는 것 예시
    때때로 나쁜 성능의 원ㅇ인을 진단하기 위해서 추가적인 항목들을 사용할 수 있다. 예를 들면 저장 프로시저 재컴파일의 경우 recompile_cause 이벤트를 통하여 문제를 일으키는 원인을 찾는다. 뒤에서 보다 자세히 설명(18장). 
    몇가지 일반적으로 사용되어지는 아래 항목들이ㅇ 있다.

        * plan_handle
        * query_hash
        * query_plan_hash
        * database_id
        * client_app_name
        * transation_id
        * session_id

    다른 정보들이 이벤트 필드의 부분에서 사용가능하다. 예를 들면 binary_data 와 integer_data 이벤트 필드는 SQL Server 액티비티에 대해 추가적인 정보를 제공한다.    그림 예시 가능한지?
    또 예를 들명 커서의 경우에서 커서 요청의 타입과 커서 생성의 타입을 지정한다. 이럼 추가적인 필드들의 이름들은 더 큰 확장의 목적으로 지정되지만 뒷 장에서 이런 글로벌 필드들의 쓸데없음을 설명할 것이다. 

- ### c. 필터들

    확장 이벤트 세션에서 이벤트와 동작들을 정의하기 위해서 다양한 필터 조건들을 설정할 수 있다. 이렇게 하여 출력 결과를 작게 만드는 것이다. 전역 필터와 이벤트 필터들에게 조건을 설정할수 있고 원하는 조건만 AND나 OR 연산자로 지정할 수 있다. 이 설정화면은 조금 헷갈리게 나오는데  그럴때는 스크립트로 출력해서 보다 명확하게 식별 가능하다. 연산자를 지정할때는 보다 적은, 같은, 보다 큰 연산자들을 사용할 수 있다.
    이 모든 조건들은 캡처되는 이벤트에 필터를 거는 것처럼 작동하며 나중에 수집된 결과물의 크기를 줄여주고 또한 분석할때도 보다 명확한 범위의 데이터만 하기 때문에 많은 시간을 줄여준다. 아래 표는 성능 분석을 위해 일반적으로 사용되는 필터 조건드ㄴㄹ이다.

    ```
    Events                  Filter Sample   UseCategory  
    ----------------------  --------------  -----------------------------------------------  
    sqlserver.username      = user_apple    단일 사용자나 로그인으로 제한
    sqlserver.database_id   = 7             sp_helpdb에 나오는 데이터베이스id로 단일 데이터베이스 제한
    duration                >= 2000         많이 사용. 2000마이크로초(0.002) 이상 소요되는 것만 캡처되게 제한. 
                                            나는 보통 3000000(3초)처럼 초를 지정함.
    physical_reads          >=2             물리적 읽기가 2 이상인것만
    sqlserver.session_id    205             sp_who에서 나오는 세션id만
    ```

    아래 그림은 duration이 3초 이상이고 논리적 읽기가 50,000 이상이면서 세션id가 342것만 필터링  
    
    ![XE이벤트필터](image/08/XEWin04_Filter.png){: width="85%"}  

    일반 비교연산자(>=)와 greater_than_equal_unit64가 따로 있다.  
    하나는 32bit int이고 하나는 부호없는 64비트 int인듯하여 본인은 항상 unit64를 쓴다.
  
- ### d. 이벤트 필드
    위에 이벤트 필터와 헷갈리지 말자. 전역필드는 모든 이벤트들에서 공통적인 항목들이지만 이벤트 필드는 특정 이벤트에서만 선택할  수있다. 또한 이벤트 필드중에서도 표준 이벤트 필드들은 자동으로 이벤트 타입에 포함되지만 수동으로 선택할 수 있는것이 아래 그림에서 나온다.

    ```
    Data Column     설명
    --------------  ---------------------------------------------  
    statement       rpc_completed 이벤트에서만 있는 SQL 텍스트
    Batch_text      sql_batch 이벤트만 있는 SQL 텍스트
    cpu_time        마이크로세컨드 단위의 CPU 비용.
    logical_reads   논리적 읽기 갯수. 8K단위의 페이지 갯수
    Physical_reads  물리적 읽기 갯수. 8K단위의 페이지 갯수
    writes          논리적 쓰기 갯수. 8K단위의 페이지 갯수
    duration        마이크로초단위의 소요시간.
    ```

    각각의 논리적 읽기나 쓰기는 메모리에서 발생하는 페이지(8KB) 갯수이며 0 또는 그 이상의 물리적 I/O 연산과 함께 발생한다.  

    ![XE이벤트필터](image/08/XEWin05_EventField.png){: width="85%"}  

    몇몇 이벤트 필드들은 선택여부를 결정해야 하지만 대부분은 자동으로 포함되어 있다. 위 그림에서 선택적 필드인 statement 가 선택되어 있다.

- ### e. 데이터 스토리지
    데이터 스토리지는 확장 이벤트 세션에 의해 수집되는 데이터들을 어떻게 저장할지를 결정하는 화면이다. 출력 메카니즘은 출력 대상에 따라 언급된다?.  일반적으로 두가지 기본 선택지가 있다. 
        * 파일로 저장
        * 버퍼에 임시 저장

    7가지의 출력 형태가 있지만 대부분은 이책의 영역에서 벗어난다. 성능 정보를 수집하려는 목적으로는 두가지 기본 선택지인 event_file과 ring_buffer만으로도 충분하다. ring_buffer는 메모리를 소모하기 때문에 작은 출력 결과가 예상될때 선택할 수 있다. 메모리상에서만 작동하기 때문에 버퍼는 시스템 메모리에 부담을 주지 않을 정도로 작게 유지 관리 되기 때문에 많은 용량의 출력이 예상되는 경우라면 버퍼의 데이터를 유실할 가능성이 높다. 쿼리 성능을 모니터링 하는 대부분의 경우 파일 출력(event_file)을 더 선호한다.  

    ![XE파일저장](image/08/XEWin06_DataStorageFile.png){: width="85%"}  

    xel확장자로 저장되는데 그 외 추가적으로 결정해야 하는 옵션은 저장할 최대 파일 크기와 롤 오버 될 경우 최대 파일 수이다. 여기서는 파일 1개가 1GB 크기가 될 것이고 그 이상이면 추가적인 파일이 생성되며 그것도 최대 1GB까지 저장할 것이다. 최대 5개까지 파일 갯수가 되며 또 이상되면 첫번째 파일이 삭제되며 해당 세션이 종료되지 않는한 영원히 이 작동 방식이 유지된다.

    버퍼나 파일이외의 다른 출력 옵션이 있지만 특별한 형태의 모니터링을 위해 예약되어지며 일반적으로 쿼리 모니터링에서는 사용하지 않는다.

- ### f. 세션 완료
    세션을 세팅하는 기본적인 절차는 다 끝났다. 고급 항목쪽은 있는데 대부분 수정하지 않고 디폴트로 사용한다. 완료를 누르면 세션이 만들어지지만 자동 시작하지 않는다. 만약 첫 화면인 일반 탭에서 "세션을 만든 후 즉시 이벤트 세션 시작"을 선택했다면 생성 즉시 시작된다. 수동으로 시작/종료는 해당 세션이름을 오른쪽 마우스 클릭해서 하면 된다.
    세션이 시작이 되면 서버의 지정된 경로에 xel 파일이 바로 만들어지며 수집을 시작하게 된다. 또한 수집되고 있는 상황을 실시간으로 볼수 있는데 세션을 오른 마우스 클릭 "라이브 데이터 감시"를 선택하면 된다.  
    새 창이 열리며 실시간으로 감시 데이터들이 보여지게 된다. 

    ![XE파일저장](image/08/XEWin07_LiveDataWatch.png){: width="85%"}  

    실시간으로 출력되는 로우중 하나를 선택하면 아래쪽에 좀더 자세한 정보들이 보여진다. 이 추가 정보들은 뒤에서 좀더 자세히 다룰 것이다. 위쪽영역에서 name 이렇게 컬럼 제목이 표시되는 곳에서 오른쪽 마우스 클릭하면 "열 선택" 하면 추가적으로 보여질 컬럼들을 선택하게 된다. 

    ![XE파일저장](image/08/XEWin08_ColumnSelect.png){: width="85%"} 

    "라이브 데이터 감시"가 유용한 이유는 실시간으로 보여지는 데이터에서 또 필터를 걸어서 결과 갯수를 조절할 수 있다. 메뉴 항목에 파일 / 편집 / 보기 옆에 확장 이벤트 라고 새로 생겼을 것이다. 거기서 필터를 선택하면 다양한 조건을 설정할 수 있다. 도구 모음에도 확장이벤트에 관련된 버튼들이 추가되어 을 텐데 거기서도 필터 버튼을 누를수 있다. 
    이렇게 실시간으로 조사를 한 후 결과를 xel 파일로 저장 할 수도 있다. 메뉴 확장 이벤트의 내보내기 / XEL 파일을 선택하면 된다. 이경우 장점은 보통 세션수집이완료되려면 몇시간 동안 기다려야 하는데 "라이브 데이터 감시"를 통해서는 바로 수집된 데이터가 보여지기 때문에 보다 능동적으로 대처할 수 있게 된다.

    또한 의심되는 로우들은 비주얼 스튜디오나 SSMS 편집기에서 처럼 책갈피를 지정할 수도 있다. 또한 프로필러에서 많이 사용했던 그룹화나 집계기능들도 역시 있다.
    화면이 실시간으로 갱신되기 때문에 분석에 불편하다면 잠시 데이터 피드를 중지하고 시작할 수 있다. 피드를 다시 시작하면 현재 수집된 데이터가 내 화면에서 사라지고 다시 "라이브 데이터 감시"를 하게 되는것이다. 서버에서 수집되는 것은 전혀 영향이 없고 내 SSMS에서만 변하는 것이다.

- ### g. 내장 system_health 세션
    SQL Server에 기본으로 내장된 system_health 세션이 있다. SQL Server 작동에 필요한 기본적인 항목들(오류나 몇가지 정보)을 모니터링 하고 있기 때문에 유용하다. 
    예를 들면 데드락의 전체 정보들이 저장된다. 
    system_health 세션은 우리가 데드락같은 기본적인 모니터링 항목의 발생 상황을 수집하기    추가적인 작업을 할 필요가 없다는 것이다.

    또한 15초 이상 래치에서 대기하고 있는 세션들의  session_id와 sql_text도 수집하고 있다. 이 정보들은 튜닝에 필요한 쿼리를 식별하는데 유용하다. 
    또한 lock을 위해 30초 이상 대기하고 있는 session_id와 sql_text도 얻을 수았다. 

    이것은 추가적인 세션이기 때문에 시스템에서 제거할수 있을 만큼 완전한 컨트롤이 가능하다. 하지만 권장하지는 않는다. 
    출력형태는 2가지이고 파일과 링버퍼

    - 파일 : 최대 크기 5MB, 롤오버 갯수는 4개이다. 파일기본 저장위치는 아래 쿼리로 확인가능.
        SELECT path
        FROM sys.dm_os_server_diagnostics_log_configurations;

    - 링버퍼 : 이벤트 수는 5000개이며 최대 메모리 크기는 4MB

## <font color='dodgerblue' size="6">2) 확장 이벤트 자동화</font>
간단하게 GUI를 통해 확장 이벤트 세션을 만들수 있지만 아쉽게도 스케일할수 있는 방법은 아니다. 다중 서버에서 동일한 종류의 확장 이벤트 세션을 만들려면 일일이 각각 접속해서 수행해야 한다. 그렇기 때문에 t-sql 명령문을 통해 수행하면 보다 수월하다.

- ### a. GUI를 통해 세션 스크립트 추출
    GUI에서 세션을 만들면 T-SQL스크립트를 추출할 수 있다.

     ![XE파일저장](image/08/XEWin09_EventScriptExport.png){: width="85%"} 

    또한 생성된 세션을 T-SQL로 시작 또는 중지할수 있다  

    ```sql
    -- 생성된 세션 시작
    ALTER EVENT SESSION QueryMetrics    ON SERVER
    STATE = START;
    ```

    SQL Agent 를 통해 이런 작업들을 자동화 할수 있고 또는 sqlcmd.exe를 이용할 수도 있다. 어찌됐든 가장 마지막 작업은 세션을 시작하는 것이다. 중지할때도 위 스크립트에서 START를 STOP으로 바꾸면 된다.

- ### b. T-SQL 로 세션 만들기

    ```sql
    CREATE EVENT SESSION [SessionSample] ON SERVER 
    ADD EVENT sqlserver.rpc_completed(SET collect_statement=(1)
        ACTION(sqlserver.client_hostname,sqlserver.sql_text)
        WHERE ([duration]>(3000000)))
    ADD TARGET package0.event_file(SET filename=N'SessionSample')
    WITH
    (
        MAX_MEMORY = 4096KB
    )
    GO

    - CREATE EVENT SESSION  : [SessionSample]라는 이름의 세션 만들기
    - ADD EVENT             : rpc_completed 이벤트 (주로 sp) 추가
    - SET collect_statement : statement는 rpc_completed만 있는 옵션 이벤트 필드인데 1인것 보니 선택됨.
    - WHERE                 : duration이 3000000(3초) 이상인 것만
    - ADD TARGET            : 파일형태의 출력이고 C:\temp\sessionsample_xxxxx.xel 로 만들어질것임
    - WITH                  : 고급 옵션을 지정. 이 세션의 처리할 임시 메모리 MAX_MEMORY = 4096KB
    ```
    
    세션이 시작되면 서버단에서 작동되며 다음 DMV로 확인 가능.

        - sys.dm_xe_sessions        : 활성화된 확장 이벤트 세션들만 보임
        - sys.server_event_sessions : 모든 확장 이벤트 세션들. 활성/비활성 모두

    다음 명령어로 세션 중지하면 sys.dm_xe_sessions에서 사라진다.  
    ```sql
    ALTER EVENT SESSION QueryMetrics ON SERVER
    STATE = STOP;
    ```    

    ```note
    확장 이벤트 세션에서 수집되는 모든 시간 정보는 마이크로세컨드 단위이지 밀리세컨드가 아니다. 필터 설정할때 조심하자.
    ```

- ### c. 인과 관계 추적
    GUI나 T-SQL 명령문에서 세션을 정의하는 것은 간단하다. 하지만 보다 실무에서는 문제되 되는 단일 배치 명령문이나 단일 SP가 아닐 것이다. 궁극적으로는 그 프로시저나 배치안에서 작동하는 각각의 sql구문들까지 원한다. statement 레벨의 재컴파일, 대기, 정렬상황은 단일 프로시저가 아닌 안에 담겨있는 각각의 스테이트먼트와 관계가 있다. 그러므르 단일 sp나 스테이트먼트와 연관된 인과관계 추적이 필요한다.

    GUI에서는 "인과 관계 추적"이며 T-SQL에서는 TRACK_CAUSALITY 를 체크하면 된다.

    ```sql
    CREATE EVENT SESSION [SessionSample] ON SERVER 
    ADD EVENT sqlserver.rpc_completed(SET collect_statement=(1)
        ACTION(sqlserver.client_hostname,sqlserver.sql_text)
        WHERE ([duration]>(3000000)))
    ADD TARGET package0.event_file(SET filename=N'c:\temp\SessionSample')
    WITH (TRACK_CAUSALITY=ON)  -- 인과관계 추적 켜기
    GO
    ```

## <font color='dodgerblue' size="6">3. 확장 이벤트 권고사항 </font>
확장 이벤트는 프로그래밍적인 방법으로 정보를 수집하는 방법에서는 기존 프로필러와 추적 이벤트와 비교해서 큰 오버헤드를 제거한 게임 체인저이다. 오버헤드를 줄이기 위해 수집하려는 이벤트나 필드의 개수를 제하하는 등 기존에는 걱정해야 하는 것을 줄였다. 그러나 이전에도 언급했듯 기존에 비해서는 매우 적어졌지만 여전한 오버헤드가 있을 수 밖에 없다. 다음과 같은 주의해야 할 점이 있다

    a. 최대 파일 크기를 적절하게 구성
    b. 디버그 이벤트와 조심하자
    c. No_Event_Loss 의 사용 피하기    

- ### a. 최대 파일 크기를 적절하게 구성
    디폴트 파일 사이즈는 1GB이다. 확장이벤트가 수집할수 있는 항목들에 비해서는 매우 적은 크기이다. 이 크기를 더 크게 설정하는 것은 좋은 생각이다. 50GB에서 100GB정도. 버퍼가 차는 동안 신규 파일 생성을 기다리는 경우 이벤트 누락이 발생 할 수 있다. 그러나 이는 시스템에 의존한다. 좋은 시스템을 가지고 있다면 각각의 환경에 맞게 파일 크기를 적절하게 구성하라.

- ### b. 디버그 이벤트에 주의
    확장 이벤트는 기존의 추적 이벤트에서 가능했던 것과 추가적 기능들 많이 능가하는 방법을 제공하여 SQL Server와 내부적 활동을 관찰하는 내부 메카니즘을 제공하고 또한 Microsoft는 SQL Server를 트러블슈팅할때도 같은 기능을 사용한다. 다수의 이벤트들은 SQL Server의 디버깅과 관련이 있다. 이들은 마법사를 통해서는 기본적으로 사용 불가능하다. 그러나 t-sql 명령어와 세션 편집기 창에서 채널 선택을 통해 접근 가능하다. 

    마이크로소프트의 직접적인 가이드없이는 사용하지 말라. 마이크로소프트 내부적으로만 사용하기 위하여 언급했던 주제들이 있다. 실험정신을 느낀다면 브레이크 액션을 포함하여 어떤 이벤트에 대한 신중한 접급이 필요하다. 이말은 이벤트가 작동되면 해당 코드가 적중되는 라인에 도달할 경우 SQL Server는 정지할 것이다. 이는 서버가 완전히 오프라인이 될것이며 알수없는 상태가 된다는 말이다. 프로덕션 서버에서 이를 행한다면 대규모 중단이 발생할 수 있으며 대규모 데이터 손실과 충돌이 된다.

    그러나 모두 중단 조치로 이어지는 것은 아니며 일부는 사용을 권장하기도 합니다. 한가지 예로 query_thread_profile 이벤트이다. 이것을 실행하면 간단한 방식으로 라이브 실행 계획 이벤트를 캡처할 수 있다. 뒤에서 실행 계획을 다룰때 보다 자세히 설명할 것이다.

- ### c. No_Event_Loss 사용 피하기
    확장 이벤트는 몇몇 이벤트 누락이 될 수도 있게 설정되어 있다. 만약 No_Event_Loss 세팅을 하면 심한 로드가 있는 시스템의 경우 버퍼에서 정보를 유지하기 위해 중요한 추가적인 로드가 생길수도 있다. 특정 행동을 목표로 하는 소규모 집중 세션의 경우 이 접근 방식이 허용될 수 있습니다.

## <font color='dodgerblue' size="6">4. 쿼리 성능 측정치를 위한 다른 방법들 </font>
확장 이벤트 세션은 나중을 위해 다양한 데이터를 수집하게 해준다. 그러나 수집은 약 간 비싸게 될 수 ㅣㅇㅆ다. 추가적으로 결과를 기다려야 한다. 그리고 우리는 대량의 데이터를 처리해야 한다. 작은 규모ㅢ 또다른 메카니즘은 쿼리 저장소이다. 뒷장에서 보다 자세히 다룰 것이다. 시스템에서 즉시 성능을 캡처하려면 DMV sys.dm_exec_query_stats와 sys.dm_exec_procedure_stats 사용한다. 히스토리 추적과 쿼리 실행 시간, 개별 비용 측정에는 여저히 확장 이벤트가 최고의 도구이다. 하지만 지금 이순간 장기 실행 쿼리나 대량의 물리적 읽기을 알고 싶다면 그럴때 이 2개의  DMV를 이용해 정보를 얻을 수 있다. 그러나 이 객체의 데이터는 캐시에 남에 있는 쿼리 플랜에 의존한다. 플랜이 캐시에서 방출되면 데이터도 날라간다. sys.dm_exec_query_stats DMO는 저장프로시저를 포함한 모든 쿼리의 결과를 리턴한다.  그러나 sys.dm_exec_procedure_stats는 오로지 저장 프로시저에 대한 결과만 리턴한다. 

이 두개의 DMO는 단순한 뷰이기 때문에 간단하게 서버의 플랜에서 쿼리들의 통계에 대한 정보를 얻는다. 아래 표는 sys.dm_exec_query_stats DMO에서 얻을 수 있는 정보들이다.

    Column                          설명
    ------------------------------  ------------------------
    Plan_handle                     실행계획에서 언급하고 있는 포인터
    Creation_time                   플랜이 만들어진 시간
    Last_execution_time             플랜이 쿼리에서 사용된 최종 시간
    Execution_count                 플랜이 사용된 횟수
    Total_worker_time               생성된 이후 플랜에서 사용된 총 CPU 시간
    Total_logical_reads             플랜이 생성된 이후 읽기 총 횟수
    Total_logical_writes            플랜이 생성된 이후 쓰기 총 횟수
    Query_hash                      같은 로직을 가진 쿼리를 식별하기 위해 사용되어지는 바이너리 해시    
    Query_plan_hash                 같은 로직을 가진 플랜을 식별하기 위해 사용되어지는 바이너리 해시    
    Max_dop                         쿼리에서 사용된 max degree of parallelism
    Max_columnstore_segment_skips   컬러스토어에서 쿼리 동안 스킵된 세그먼트의 개수

sys.dm_exec_query_stats에서 보여지는 정보를 필터하기 위해서 sys.dm_exec_sql_text와 같은 DMF를 조인할 필요가 있다. 이 함수는 플랜과 연관된 쿼리를 보여준다. 또는 쿼리의 실행계획인 sys.dm_query_plan . 일단 이런 DMO와 조인하면 원하는 데이터베이스나 프로시저를 필터링 할수있다. 이런 종류의 다른 DMO들은 뒷장에서 자세히 다룰 것이다. 여기서는 sys.dm_exec_query_stats와 다른 것들의 사용 예제를 섞어서 나머지 부분에서 보여준다. 이런 쿼리들은 캐시 의ㅣ존이런것에 주의해라. 실행계획이 캐시밖으로 나가게 디면 이 정도는 사라진다.





## <font color='dodgerblue' size="6">5. 요약 </font>
이번 장에서는 시스템에 많은 양의 부하를 발생시키는 쿼리들을 식별하기 위해  확장이벤트를 사용하는 것을 설명했다. 세션데이터 수집은 시스템 저장 프로시저를 사용해 자동화 되는것이 좋다. 실행중인 쿼리에 대한 통계에 즉각적인 접근하기 위해 DMV sys.dm_exec_query_stats를 사용해라

이제 시스템에 대해 실행된 쿼리에 대한 메트릭을 수집하는 메커니즘이 있으므로 다음 장에서는 이러한 측정 도구에 의존할 필요가 없도록 쿼리가 실행될 때마다 쿼리에 대한 정보를 수집하는 방법을 탐색할 것입니다.