---
sort: 8
---

# Query 성능 수집
느린 SQL Server 성능의 일반적인 원인은 과도한 데이터베이스 응용 프로그램 워크로드, 즉 쿼리 자체의 특징과 양이다. 그러기에, 시스템 병목의 원인을 분석하기 위해서는 데이터베이스 어플리케이션 워크로드를 조사하여 시스템 리소스에 가장 큰 스트레스를 일으키는 SQL 쿼리를 식별하는 것이 중요하다. 
이를 하기 위해 **확장 이벤트**와 **다른 매니지먼트 스튜디오 툴**을 이용할 수 있다.

이번 장에서는 다음과 같은 내용을 설명한다.

    * 확장 이벤트 기본
    * 확장 이벤트를 이용하여 SQL Server 워크로드를 분석하고 비용이 많이 소모되는 SQL 식별하는 방법
    * 동적관리오브젝트(DMO)로 쿼리 성능 추적하는 방법

## <font color='dodgerblue' size="6">1) 확장 이벤트(XE)</font>
확장이벤트는 SQL Server 2008에서 처음 소개되었지만 GUI는 없었고 세팅하기가 매우 복잡핬다. 성능 측정치를 캡처하기 위해 많이 사용되지 않았ㄷ. 2012가 되서야 확장이벤트를 관리하기 위한 GUI가 소개되었고 성능수치를 수집하기 위한 우선순위 옵션이 되었다. 이전에 프로필러와 같은 툴로 수집하는 가장 선호하는 방법이었던 추적 이벤트 기능은 점점 비추천 되었고 더이상 개발되지도 않는다. 몇년동안 어떤 추적 이벤트 기능도 추가되지 않았다. 프로필러는 운영서버에서 적절하지 않게 사용될 경우 성능상 오버헤드가 발생할 수 있다. 결과적으로 이 책의 예제들은 주로 확장 이벤트를 사용할 것이며 두번째로는 쿼리 저장소를 사용할 것이다.

확장 이벤트는 다음과 같은 기능이 있다.

    * SQL Server 쿼리를 그래픽UI로 모니터링
    * 백그라운드에서 쿼리 정보 수집
    * 성능 분석
    * 데드락 같은 문제 진단
    * Transact-SQL(T-SQL) 디버깅

SQL Server 인스턴스에서 수행되는 여러 종류의 활동을 캡처하기 위해서도 확장 이벤트를 사용할 수 있다. 그래픽UI나 쿼리 명령어를 이용해 설정 할 수 있다. 확장 이벤트 세션을 만드는 가장 효과적인 방법은 T-SQL 명령어를 이용하는 것이다. 그러나 GUI를 통해 세션에 대해 배워나가는 것도 좋은 선택지이다.

## <font color='dodgerblue' size="6">2) 확장 이벤트 세션</font>
SSMS GUI안에 내장되어 있는 확장 이벤트를 발견 할 것이다. 오브젝트 탐색기를 통해 찾아가다 보면 확장 이벤트 폴더를 찾을 수 있다. 거기에서 이미 만들어져 있는 시스템 세션들을 볼 수 있다. 새로운 세션을 만들기 위해서는 세션 폴더를 오른쪽 마우스 클릭하고 새 세션을 누른다. 세션을 설정하는 데 사용할 수 있는 마법사가 있지만 일반 GUI가 하지 않는 작업은 수행하지 않으며 일반 GUI는 사용하기 쉽습니다. 새 창이 열리며 일반 설정으로 시작한다.
![XE시작화면](image/08/XEWin01_StartWin.png){: width="80%"}  

이 화면에서 세션이름을 지정해 준다. 나중에 명확하게 알 수 있게 명확한 이름을 지정하는 것을 권고한다. 또한 템플릿을 사용할수 있다. 프로필러를 사용할 때와 같이 미리 설정된 템플릿을 이용하면 최소의 노력으로 만들 수 있다.  
"쿼리 실행" 카테고리안에 쿼리 튜닝과 연관된 5개의 템플릿이 있고 다음과 같다

    * 쿼리 일괄 처리 샘플링 : 활성 세션의 20%만 쿼리와 프로시저 수집.
    * 쿼리 일괄 처리 추적 : 모든 쿼리와 프로시저 수집하기에 주의 요망
    * 쿼리 정보 샘플링 : 활성세션의 20%의 쿼리와 프로시저의 모든 스테이트먼트 수집.
        sp_statement_completed, sql_statement_completed, module_end가 추가됨
    * 쿼리 정보 추적 : 모든 쿼리와 프로시저의 스테이트먼트 수집.
        역시 sp_statement_completed, sql_statement_completed, module_end가 추가되기에 주의 요망.
        데이터 스토리지를 ringbuffer로 해서 조금 다행이지만 서버 뻗을수도 있지 않ㅡㅇㄹ까?
    * 쿼리 대기 통계 : 모든 활성 세션의 20%에 해당하는 쿼리, 프로시저의 스테이트먼트에 대한 대기 통계 수집.

게다가 프로필러에서 자주 사용한 항목들을 가져온 템플릿들도 있다. 또한 2017에서 소개되었으며 최소의 노력으로 빠르게 쿼리성능을 조사하는 추가적인 하나의 방법이 있다. 개체 탐색기의 아래부분에 XEvent 프로파일러라는 새로운 폴더이다. 폴더를 확장해보면 프로필러에서 주로 보았던 것을 비슷하게 쿼리 모니터링을 정의한 두개의 확장 이벤트 세션을 발견할 수 있다. 이번 장 뒤에서 라이브 데이터 감시라는 기능을 통해 함께 설명한다. 이것을 실행하는 대신 템플릿을 건너뛰고 XE 프로파일러 나만의 이벤트를 세팅하기 위하여 리포트 해주기에 완료된 방법을 볼 수 있다. 
```note
꽁짜거나 위험인 없는 일은 세상에 없다. 확장이벤트는 예전 프로파일러나 추적이벤트보다 시스템 정보를 수집하는 더 효과적인 메카니즘이다. 하자만 비용이나 위험이 없을 수는 없다. 이 장의 뒤에서 좀더 자세히 설명하겠지만 몇몇 전역 필드에 의존하여 하나의 충격을 볼수 있을지도 모른다. 운영 시스템에 네거티브 임팩트가 없는지 확인하기 위해 충분히 조심하여 미리 연습하자. 쿼리 저장소는 더 적은 임팩트가 있게 많은 정보를 제공해 주고 DMO들로 보다 적은 임팩트를 얻을 수 있다. 이런 대체 방법은 몇가지 상황에서 작업할수 있다.
```
세션만들기 첫번째 창에서 이름을 적는 이외에 몇가지 다른 옵션들이 있다. 서버 시작할때 자동으로 시작되도록 결정할 수 있다. 오래동안 성능 항목들을 수집하면 할수록 저장되는 수집 데이터 크기도 증가한다. 생성과 동시에 시작과 라이브 데이터 감시를 바로 할수도 있다. 마지막으로 이벤트 관계 추적을 설정할 수 있다. 이에 대한 자세한 설명은 뒤에서 한다.

새 세션 창은 이미 마법사와 거의 근접하다. 다음 버튼을 누르면 추적하기 원하는 이벤트를 추가하는 창이 열린다. 이벤트 라이브러리에 원하는 이벤트의 일부 단어를 쳐도 like 검색이 되어 편리하다.
![XE이벤트추가](image/08/XEWin02_AddEvent.png){: width="85%"}  

여기에는 이벤트 대상, 이벤트 패키지, 이벤트 세션등으로 구성되어 있는 이벤트 아키텍처가 존재한다. 하지만 GUI사용은 그런 세부사항에 대해 걱정하지 않게 해준다. 뒷부분에서 세션을 스크립팅하는 방법을 보여줄때 일부 아키텍처 부분들도 같이 한다.

성능 분석을 위해서, SQL Server에서 수행되어지는 다양한 활동들의 리소스 스트레스의 레벨을 판단하는데 도움을 주는 이벤트들에 주로 관심을 가질 것이다. 리소스 스트레스에 의해 다음과 같은 다양한 것들을 의미한다.

    * 어떤 종류의 CPU 사용이 T-SQL 활동에 포함되나?
    * 얼마나 많은 메모리가 사용되나?
    * 얼마나 많은 I/O가 포함되나?
    * 얼마나 오래 SQL이 실행되나?
    * 얼마나 빈번하게 특정 쿼리가 실행되나?
    * 어떤 종류의 에러가 경고가 쿼리에서 발생하는지?

우리는 이벤트의 종료후에 SQL에 의한 리소스 스트레스를 계산할 수 있다. 그래서 성능 분석에 사용하는 주된 이벤트들은 SQL 활동의 완료를 대표하는 것이다. 리스트는 다음과 같다.

    ```
    Event Category      Event                       설명
    ------------------- --------------------------  ----------------------------------
    Execution           rpc_completed               원격 프로시저 호출 완료시. 주로 sp완료
                        sp_statement_completed      sp안의 sql 구문 1개 종료시
                        sql_batch_completed         T-SQL 일반 쿼리가 종료시
                        sql_statement_completed     T-SQL 일반 쿼리의 1개 sql 구문 종료시
    ```

RPC 이벤트는 OLEDB명령어 통하여 원격 프로시저 호출(Remote Procedure Call) 메카니즘을 사용할때 발생한다. 데이터베이스 어플리케이션이 T-SQL의 Execute 구문을 통해 sp를 실행시킬 경우에는 RPC보다는 SQL 배치로 해석된다. 

T-SQL 배치는 SQL서버에 함께 보내지는 SQL쿼리들의 묶음이며 보통 GO 구문으로 나누어진다. GO 구문은 T-SQL 구문이 아니다. 대신에 GO구문으로 sqlcmd 유틸리티를 사용할때 1개의 배치를 인식하도록 한다. 또한 ssms에서도 사용되며 1개의 단일 배치로 묶는다. 1개의 배치에 있는 각각의 SQL 쿼리는 T-SQL 구문(스테이트먼트)라고 부른다. 그러기에 T-SQL 배치는 1개 이상의 T-SQL 구문으로 구성된다. 구문 또는 T-SQL 구문은 각각 별개의 명령어이다. sp_statement_com;eted와 sql_statement_completed 이벤트는 쿼리안의 개별 스테이트먼트가 많으면 많을 수록 더 비싼 연산 이 될수 있다. 
XEvent 세션 활동은 쿼리를 수집하는 행위와 수집완료한 쿼리 정보를 별도의 저장소(주로 로컬 하드디스크)에 저장하는 두가지 측면을 고려해야 한다. 프로시저안에 여러개의 스테이트먼트가 있고 그 스테이트먼트가 또 다른 프로시저를 호출하는 등의 경우가 있는 경우에는 시스템에서 분명하게 인식할 수 있을정도의 로드가 된다. 스테이트먼트를 완전하게 수집하는 충격은 크기와 수집하려하는 스테이트먼트들의 숫자에 의존한다. 스테이트먼트 완료 이벤트는 특히 운영 시스템에서는 신중하게 수집해야 한다. 그러기에 이런 이벤트들에서 반환을 제한하기 위해 필터를 사용해야 한다. 필터는 뒤에서 다룬다.

세션에 이벤트를 추가하기 위해서 이벤트 라이브러리를 찾는다. 간단하다. 원하는 이벤트를 치면 like 검색이 되어 나타난다. 위의 그림에서 sql_batch를 치니까 결과가 여러개 나왔다. 원하는 이벤트를 더블클릭하거나 오른쪽 화살표를 누르면 오른쪽의 "선택한 이벤트" 영역으로 이동한다. 역시나 제거할 경우에도 더블클릭하거나 왼쪽 화살표를 누르면 "선택한 이벤트" 영역에서 제거된다. 

표에 있는 이벤트 리스트들이 성능 수집할때 가장 많이 사용하는 이벤트들이지만 다른 측정항목을 수집하기 위해서 다양한 이벤트들을 추가할 수 있다. 예를 들면 1장에서 다루었던 반복되는 sp 재컴파일을 추적하기 위해 sql_statement_recompile을 추가하는 것처럼. 이벤트 라이브러리는 데이터베이스 워크로드와 같은 기타 성능 관련 이슈들을 수집하기 위한 추가적인 이벤트드ㅡㅇㄹ 포함한다. 아래 표는 이런 종류의 몇가지 이벤트들이다.

    ```
    Event Category  Event                           설명
    --------------  ------------------------------  ----------------------------------
    Session         login                           SQL Server에 연결 또는 연결종료할때 발생
                    logout  
                    exisiting_connection            세션이벤트를 만들기 전에 이미 만들어져있는 연결 정보
    Erros           attention   
                    error_reported                  에러가 보고될때 발생
                    execution_warning               명령문에 대한 메모리 할당 대기가 1초이상 지속되거나 또는 메모리 할당이 실패하거나
                    hash_warning                    해시 연산에서 충분하지 않은 메모리 발생시. 어떤 연산이 에러 났는지 이해하기 위해서는
                                                    실행계획 캡처와 함께 수행해야
    Warning         missing_column_statistics       옵티마이저가 프로세싱 전략을 결정하기 위해 필요한 컬럼의 통계정보가 없을경우
                    missing_join_predicate          쿼리가 두개의 테이블간에 조인 예측전략 없이 실행되는 경우
                    sort_warning                    SELECT와 같은 쿼리에서 수행되는 정렬 연산할때 메모리가 부족할 경우
    Lock            lock_deadlock                   deadlock 희생이 발생할때
                    lock_deadlock_chain             데드락을 만드는 쿼리의체이의 추적을 보여준다.
                    lock_timeout                    SET LOCK_TIMEOUT (ms)가 세팅되었을때 그 시간 초과하는 경우
    Execution       sql_statement_recompile         쿼리 명령문의 실행계획이 재컴파일되는 경우.          
                                                    1. 존재하지 않거나
                                                    2. 강제로 재컴파일
                                                    3. 이미 있지만 사용되지 않아서
                                                    배치레벨이 아닌 명령문 레벨. ad-hoc쿼리, sp, 프리페어드 sql 무도 상관없이
                    rpc_starting                    sp 실행시. sp가 실행은 했지만 오래 걸려 종료되지 않았을 경우 사용.
                    query_post_comilation_showplan  SQL 명령문이 컴파일된 후 실행계획 보여줌
                    query_post_execution_showplan   SQL 명령문이 실행된 후 실행계획 보여줌. 실행통계 포함.
                                                    주의) 이 이벤트는 높은 비용이 될 수 있기에 적절한 필터를 설정해서 짧은기간 측정해야 한다.
    Transactions    sql_transaction                 데이터베이스 트랜잭션에 대한 정보 제공. 트랜잭션 시작, 종료, 롤백할때 정보 포함.
    ```