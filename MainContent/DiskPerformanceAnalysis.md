---
sort: 3
---

# Disk Performance Analysis


컨트롤러와 커넥터 및 관리 소프트웨어를 포함하는 디스크와 디스크 하위 시스템은 모든 컴퓨팅 시스템에서 가장 느린 단일 부분 중 하나입니다. 수년에 걸쳐 메모리와 CPU는 계속해서 더 빨라졌습니다. 하지만 최근에 SSD (Solid-State Disk)와 같은 기술로 본 급격한 개선 사항을 제외하고 디스크는 그다지 변하지 않았습니다. 디스크는 여전히 대부분의 시스템에서 가장 느린 부분 중 하나입니다. 즉, 디스크의 동작을 이해하기 위해 디스크를 모니터링 할 수 있기를 원할 것입니다. 이 장에서는 다음과 같은 영역을 살펴 봅니다.

* 디스크 성능 수치를 측정하기 위한 시스템 카운터 사용
* 디스크 활동을 수집하는 다른 메카니즘 활용
* 디스크 성능 이슈 해결

## 3.1 디스크 병목 분석    
SQL Server에는 까다로운 I/O 요구사항이 있을 수 있으며 디스크 속도는 메모리와 CPU에 비해 상대적으로 매우 느리다. 디스크 자원 경합은 SQL Server의 성능을 심각하게 다운 시킬수 있다.  
그렇기 디스크 자원에서 병목 분석과 해결책은 SQL Server의 성능을 급격히 향상 시킨다.

### 디스크 카운터

```
Object(Instance)  Counter                   Description                                     Value
----------------  --------------            ---------------------------------------------   ---------------------------------------
PhysicalDisk      %Disk Time                디스크가 바쁜 비율                              평균 85% 이하여야 하지만 베이스라인 참고
                  Current Disk Queue Length 성능 데이터를 수집 할 때 미해결 디스크 요청 수  베이스라인과 비교
                  Avg. Disk Queue Length    샘플 간격동안 대기중인 디스크 요청 평균 개수    베이스라인과 비교
                  Disk Transfers/sec        디스크 연산중 읽기 쓰기 비율                    I/O 서브시스템의 최대값
                  Disk Bytes/sec            초당 디스크에 접근하는 데이터 전송량            I/O 서브시스템의 최대값
                  Avg.Disk Sec/Read         디스크에서 읽는 평균 시간(ms)                   평균 값 10ms 보다 작아야. 베이스라인 참고
                  Avg.Disk sec/Write        디스크에 쓰는 평균 시간(ms)                     평균 값 10ms 보다 작아야. 베이스라인 참고
```

PhysicalDisk 카운터는 물리 디스크를 말하고 LogicalDisk는 드라이브 파티션(C: D: E:) 과 같은 지표를 말한다. 하지만 디스크 병목은 물리적 디스크에서 일어나므로 PhysialDisk 카운터를 주로 사용하게 된다.

RAID와 SAN과 같은 디스크 지원 시스템에서는 모두 1개의 물리적 디스크로 집계되기 때문에 실제 각 물리 디스크의 속도와는 틀린 데이터가 측정된다.  
각 서브시스템에 맞게 수치를 곱하거나 나누어서 실제 물리적 수치를 보정해줘야 한다. 또한 SSD같은 좀더 빠른 디스크의 가격이 시간이 지나면서 점점 싸지고 있기 때문에 적극 이용해야 하며 최소한 iSCSI같은 것으로 바꿔야 한다. 기존의 플래터를 가지는 일반 하드디스크를 DB Server의 저장소로 쓰는 경우는 점차 줄어들고 있으며 백업 장치나 이런것으로만 주로 사용되는 패턴으로 변하고 있다.

### * % Disk Time
% Disk Time은 해당 디스크의 활동(read/write)의 퍼센트이다. 디스크가 바쁘게 사용되는지 알 수 있는 가장 직관적인 카운터이지만 실제 병목을 알기 위해서는 적합치 않다. 80%, 90%의 수치가 병목없이 계속 이어진다면 바쁘기만 할 뿐인 디스크이다. 이 때는 아무 조치도 하지 않아도 되기에 그렇다. 다만 디스크 베이스라인 데이터와 비교할때는 유용하다. 전 달에서 바뻐지면 사용량이 늘고 앞으로 언제 증설이 필요한지 앝 수 있기 때문이다.

### * Current Disk Queue Length
디스크 I/O 작업을 요청했을때 해당 시점에 디스크가 바뻐 처리하지 못하고 대기하고 있는 개수, 즉 대기순번 갯수라고 생각하면 된다. 하지만 최근에는 SAN, RAID와 같은 디스크 어레이 시스템들이 실제 큐에 있는 작업들을 뒤에서 나눠서 처리하기 때문에 시간이 지날수록 이 수치에 대한 기준이 낮아지고 있다. 그럼에도 불구하고 바쁜 DB에서는 큐 길이가 증가할 수 있기 때문에 가장 직관적으로 디스크 I/O 병목 문제를 알아 챌수 있는 카운터이기도 하다. 예전에는 이 수치가 4를 넘으면 그때부터 병목이라는 기준이 있기도 하였으나 최근에는 RAID, SAN과 같은 어레이 시스템이 일반적이기 때문에 4보다 적은 숫자가 기준이다. 절대적으로 고정된 수치는 없기에 베이스라인 데이터를 참고해 시스템별 기준을 만들어야 한다.  

IBM기준으로는 여전히 4이상이면 병목이고 2이상이면 문제가 있다고 함.

### * Disk Transfer/Sec
이 카운터는 디스크의 읽기 및 쓰기 작업 속도를 모니터링합니다. 오늘날의 일반 하드 디스크는 순차 I/O (IOPS)의 경우 초당 약 180 번, 랜덤 I/O의 경우는 그보다 떨어지는 초당 100회 정도의 전송 속도를 가진다. 하드디스크의 랜덤I/O 액세스는 디스크 암과 헤드를 움직이는데 많은 시간을 잡아먹기 때문에 더 낮을 수밖에 없다. MSSQL의 데이터파일과 같은 랜덤액세스 OLTP 환경에서는 이런 구조적인 제약 때문에 1000MB/sec의 처리량을 가지는 디스크이라 해도 초당 100회 정도의 디스크 전송 횟수만 수행 할 수 있다.

또한 IOPS의 입출력 단위는 일반적으로 4K 단위로 측정하기 때문에 64K 단위인 MSSQL와는 다르다. 50,000 IOPS라고 스토리지 업체가 얘기한다면 우리는  16로 나눈 3,125(64K기준) 정도라고 바꾸어 생각해야 한다.  
그리고 AWS에서 SSD는 7,000 IOPS가 16KB 단위이기 때문 실제로는 4로 나눈 1,750 IOPS(64K기준)가 맞다.

Note
    SSD는 일반 하드디스크의 50 ~ 100배의 IOPS 수치를 가지며 약 5,000부터 500,000 IOPS의 하이엔드까지 다양하다. 그렇기에 Disk Transfer/sec 수치를 디스크 종류에 따라 적절하게 스케일링해서 판단해야 한다.

성능 측정데이터는 디스크의 느린 전송속도때문에 가능한 낮게 판단해야 한다.    

### * Disk Bytes/Sec
읽기/쓰기 작업으로 인하여 디스크로 전송되는 초당 바이트. 7200RPM의 전통적인 디스크는 약 초당1000MB을 전송할수 있다. 일반적으로 작은 양을 데이터를 읽고 쓰는 OLTP에서는 대부분 이 대역폭을 넘길 일이 잘 없다. 만약 이를 초과하는 경우가 생긴다 하더라도 Disk Queue Length와 같은 카운터 값이 증가하기 때문에 병목이 생김을 알 수 있다.  
 SSD는 하드 디스크와 같은 지연시간(암과 헤드가 위치를 찾아가는 시간)이 거의 없기 때문에 훨씬 많은 데이터를 전송한다.

 ### * Avg. Disk Sec/read, Avg. Disk Sec/Write
디스크로 읽고 쓰는데 소요되는 밀리세턴드 단위의 시간. I/O에 문제가 있는지 판단하는 가장 명확한 지표. 10ms 이상이라면 하드웨어나 구성정보가 제대로 세팅되었는지 확인해야 한다. 트랜잭션 로그가 잘 작동하는지에 대한 정확한 시간을 얻을 필요가 있다.

## 3.2 추가적인 I/O 모니터링 도구

### * sys.dm_io_virtual_file_stats
데이터 및 로그 파일에 대한 I/O 통계를 반환하는 DMF.  
결과 중 가장 흥미로운 것은 stall data들이며 다른 I/O 작업을 대기하는 시간의 총 합이다. 단위는 ms이고 서버가 기동한 후의 데이터들.  

첫째로 io_stall_read_ms은 읽기 총 대기 시간이며 io_stall_write_ms는 쓰기 총 대기 시간.  
또한 전체 i/o를 대기하는 io_stall 도 있다.  
이 숫자들은 서버가 기동한 이후의 합산 데이터이기 때문에 마찬가지로 서버가 기동한 후의 총 ms인 sample_ms와 stall data들을 비교하여 나누어야만 I/O 문제가 시스템에 문제를 일으키는지 수치를 파악할 수 있다. 어떤 로그파일 또는 데이터 파일에서 속도를 저하시키는지 범위를 좁혀가면서 찾아 낼 수 있다. 이것은 I/O 병목의 존재만을 확인하는 데 매우 좋은 측정방법이지만 병목의 종류를 파악하는 데는 그다지 도움이되지 않는다.

```sql
SELECT file_id
    , sample_ms, num_of_bytes_read, io_stall_read_ms
    , io_stall_read_ms / sample_ms ReadWait_ms
    , num_of_bytes_written, io_stall_write_ms, io_stall    
    , io_stall_write_ms / sample_ms WriteWait_ms
FROM sys.dm_io_virtual_file_stats(DB_ID('CNJ_FCS_CELL_P01'), NULL) AS divfs
ORDER BY io_stall_read_ms desc

/*    
    file_id  sample_ms  num_of_bytes_read  io_stall_read_ms  ReadWait_ms  num_of_bytes_written  io_stall_write_ms  io_stall     WriteWait_ms
    -------  ---------  -----------------  ----------------  -----------  --------------------  -----------------  -----------  --------------------
    1        771527487  90132529274880     5046885577        6            25389803593728        53533716474        58580602051  69
    4        771527487  383154882199552    4221191163        5            85669898698752        70174055125        74395246288  90
    124      771527487  35376300834816     1488460578        1            33114379141120        66340402447        67828863025  85
    5        771527487  76607142281216     726599361         0            6579059138560         8919686088         9646285449   11
    39       771527487  12743186497536     516798864         0            7619623796736         12216171672        12732970536  15
    2        771527487  35920934462976     379717729         0            113794634384896       3178572288         3558290017   4
    40       771527487  4317579722752      268489573         0            6424399806464         7542018819         7810508392   9


    여기서 1번 파일의 읽기 대기가 ReadWait_ms 가 6이고 WriteWait_ms가 69이니 읽기도 대기가 걸리지만 쓰기도 심하게 걸림을 알수있다.
   
    해결방법
    1. 문제의 원인을 제거
        (악성쿼리나 배치작업을 튜닝하는등 읽기 쓰기 작업을 아예 줄이기)
    2. 디스크 I/O 분산
        - 더 빠른 디스크로 바꾸거나
        - 상위 10개의 I/O 나쁜 데이터파일을 별도의 물리디스크로 서로 분산 전략 (현재 이 DB는 한군데에 몰려있다.)
*/  
```
sample_ms는 정수형값이기에 SQL Server 최근 기동시간이 아주 오래 전이라면 이 값이 음수가 나올 수 있다. 대략 10개월정도. 현재 나의 SQL Server은 2014.

### * sys.dm_os_wait_stats
SQL Server에서 모든 대기현상을 알아내는데 일반적으로 사용하는 DMO. I/O 병목을 식별하는데도 유용하며 다음과 같이 사용한다.
값은 모두 합계나 시간의 총합, 최대값등이 표시된다.

```sql
SELECT *
FROM sys.dm_os_wait_stats AS dows
WHERE wait_type LIKE 'PAGEIOLATCH%';
```
위 쿼리는 대기를 발생시키는 다양한 I/O 래치를 찾을 수 있다. sys.dm_io_virtual_file_stats와 마찬가지로 이 DMO에서 I/O문제를 발생시키는 특정한 쿼리를 얻을수는 없다. 또한 성능카운터처럼 문제의 수치를 직관적으로 얻을 수 없고 현재 값을 기존 베이스라인 데이터와 비교하여 판단하여야 한다.

PAGEIOLATCH% 와 같이 IO와 관련된 조건(WRITELOG, LOGBUFFER, ASYCN_IO_COMPLETION)을 검색해서 다른 I/O 대기도 조사할 수 있다.   
이 DMV는 총 시간과 합계를 나타나기 때문에 가장 긴 대기시간이 무엇인지 알 수 있다.

## 3.3 디스크 병목 해결방법

    * 어플리케이션 워크로드 최적화
    * 더 빠른 I/O 경로 사용
    * RAID 어레이 사용
    * SAN 시스템 사용
    * SSD 사용
    * 디스크 적절 배열
    * 배터리 대비 컨트롤러 캐시
    * 시스템 메모리 추가
    * 다중 파일과 파일그룹 만들기
    * 로그 파일을 별도의 물리 디스크로 이동
    * 파티션 테이블 사용

### 어클리케이션 워크로드 최적화
성능 문제를 해결하는데에 어플리케이션 워크로드 최적화가 얼마나 중요한지 아무리 강조해도 지나치지 않을 것이다. 매우 높은 읽기/쓰기를 발생시키는 쿼리는 엄청난 디스크 I/O 문제를 일으키는 원인 중 하나이다. 이 책의 나머지 부분에서 그런 쿼리들을 최적화하는 전략에 대해 좀더 자세하게 설명 할 것이다. 

### 더 빠른 I/O 경로 사용
가장 효과적인 해결방법 이자 언제든지 채택 할 수 있는 방법중 하나는 드라이브, 컨트롤러 등을 더빠른 초당 디스크 전송 능력을 가지는 것으로 교체하는 것이다. 그러나 충분한 조사없이 디스크 업그레이드를 하면 안되며 디스크 스트레스를 유발하는 원인을 먼저 찾을 필요가 있다.

### 디스크 어레이 사용
디스크 I/O 병렬 처리 방법을 얻는 한가지 방법은 모든 SQL Server 데이터파이을 하나의 단일 드라이브 풀을 만드는 것이다. 단 트랜잭션 로그 파일 제외.
풀은 하나의 RAID 어레이가 될수 있고 Winwos OS에서는 단일 물리 디스크로 보인다. 드라이브 풀의 효율성은 RAID 디스크 구성에 따라 다르다.  
가장 일반적으로 널리 사용되는 RAID 구성은 다음과 같다

    * RAID 0 : 결함 허용이 없는 스트라이프 셋
    * RAID 1 : 미러링
    * RAID 5 : 패러티 있는 스트라이프 셋
    * RAID 1 + 0 : 미러링 있는 스트라이프 셋. RAID 10(ten) 이라고 보통 부름.

    그림

RAID 0  
    결함 허용이 없는 구성이므로 데이터 안정성이 중요하지 않은 상황에서만 사용한다. 어레이 상의 한 디스크가 실패하면 완전한 데이터가 완전히 유실된다.
    따라서 tempdb와 같은 임시 데이터베이스를 제외하고 실제의 데이터파일이나 트랜잭션 로그 파일용으로 사용하면 안된다.  
    RAID 0에서 디스크 당 I/O 수치는 아래와 같이 계산 된다.

    디스크 당 I/O = (Reads + Writes) / 어레이의 디스크수

RAID 1  
    데이터 디스크를 별도의 디스크에 미러링하기때문에 높은 수준의 결함 허용을 제공한다. 전체 데이터를 오로지 한 디스크에 유지하려 할때 사용될 수 있다. 예를 들면 트랜잭션 로그 파일, OS 시스템 파일, SQL Server 시스템 데이터베이스(master, msdb)의 경우가 그러하며 RAID 1으로 사용하기 위하여 충분지 작은 경우가 대부분.  
    
    => 디스크 당 I/O = (Reads + 2 x Writes) / 2
       미러링 디스크이기 때문에 쓰기는 2번 해야 한다.