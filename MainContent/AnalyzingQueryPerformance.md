---
sort: 9
---

# Query 성능 분석
이전장에서 쿼리 성능 데이터 수집하는 방법을 설명했다. 이번에는 수집한 데이터에서 문제되는 쿼리(장기간 실행되거나 빈번히 호출되는 쿼리)를 찾아내는 방법을 설명할 것이다. 우리는 SSMS에 내장된 도구를 이용하여 쿼리가 실행되는 방법을 이해할 수 있을 것이다. 이번 장 대부분의 시간동안  실행계획에 설명할 것이며 이는 쿼리 옵티마이저에 의해 만들어지는 최상의 계획이다.

다음과 같은 것을 설명한다.

    - SQL 쿼리의 비용 처리 전략을 SSMS를 이용하여 분석하는 방법
    - 쿼리 옵티마이저가 SQL 쿼리를 분석한 방법을 분석하기
    - T-SQL 명령어를 사용하여 SQL 쿼리의 비용을 측정하는 방법

## <font color='dodgerblue' size="6">1) 고비용 쿼리</font>    
여태까지 우리는 쿼리 성능데이터를 수집하기 위해 두가지 다른 방법을 사용해 왔다. SQL Server의 성능은 언제 나빠질까? 몇가지 경우가 가장 빈번하게 발생한다.
    - 첫째, 어떤 쿼리들은 시스템 리소스에 큰 스트레스를 생성한다. 이런 쿼리들은 서버가 감당할수 없을 정도의 부하를 주게되어 전체 시스템의 성능에 영향을 미친다. 
    - 둘째, 고비용 쿼리는 같은 데이터베이스 자원을 요청하는 다른 쿼리들을 블로킹하기도 하여 이런 쿼리들의 성능을 저하시킨다. 고비용 쿼리들을 최적화하면 자기 스스로도 빨라지지만 데이터베이스 블로킹을 줄여주고 SQL Server 리소스 압박도 감소시킨다.
    - 쿼리에게 전달되는 데이터나 값의 변화는 쿼리의 활동 변화를 발생시키며 성능을 저하시킬수 있다.
    - 마지막으로 그 자체로 비용이 많이 들지 않는 쿼리는 1분에 수천 번 호출될 수 있으며, 이는 단순히 최적 코드 미만의 누적으로 인해 주요 리소스 병목 현상으로 이어질 수 있습니다. 

가장 비용이 많이 소모되는 쿼리를 확정하려면 지금까지 설명한 것들을 사용해야 합니다. 예를 들어 쿼리가 캐시에 있다고 가정할 경우, DMO를 사용하여 의미 있는 데이터를 모으고 그중에서 가장 비용이 소모되는 쿼리를 결정할 수 있습니다. 또는 확장 이벤트를 사용하여 쿼리를 캡처했기 때문에 가장 비용이 많이 드는 쿼리를 식별하는 수단으로 해당 데이터에 액세스할 수 있습니다. SQL Server 2016에서 소개된 다른 하나의 옵션인 쿼리 저장소 역시 가능하다. 뒷장에서 자세히 메카니즘을 소개할 것이다.

여기서는 확장 이벤트를 시작할 것이다. 쿼리데이터를 캡처하기위한 단일의 가장쉽고 가장 직접적인 방법은 현재 캐시에 있는 쿼리를 DMO를 통해서이다. 불행하게도 이것은 집계된 데이터이고 완전하게 캐시안에 있는 데이터에 의존한다. 뒷장에서 캐시에 대해 얘기할 것이다. 그래서 계층적 레코드를 가지지 않고 저장 프로시저의 각각의 실행 데이터와 그에 따른 파라메터를 얻지 못한다. 쿼리 데이터를 조사하는 두번째 쉽고 직접적인 방법은 쿼리 저장소를 이용하는 것이며 DMO보다 더 완전한 기록을 제공한다. 그러나 집계된 형태는 동일하다. 우리는 세가지 모두를 살펴볼것이며 정확도를 위해 확장 이벤트를 시작할 것이다.

확장 이벤트에서 하나의 작은 주의사항은 파일로 수집된다면 수집완료후 테이블로 수집 데이터를 로드할 필요하다 또는 바로 쿼리로 실행하거나. 시스템 함수를 사용하여 쿼리를 함으로써 확장이벤트 결과 파일에서 바로 읽을 수있다.

```sql
SELECT module_guid,
    package_guid,
    object_name,
    event_data,
    file_name,
    file_offset,
    timestamp_utc
FROM sys.fn_xe_file_target_read_file('C:\Sessions\QueryPerformanceMetrics*.xel',
    NULL, NULL, NULL);
```

 함수의 첫번째 파라메터는 확장이벤트결과파일(.xel)의 경로이다. *를 통해 여러개의 파일을 한번에 로드할 수 있다. 두번째 파라메터는 2008R2까지는 사용되었지만 그 이후 버전에서는 사용되지 않는다. 세번째 파라메터는 초기파일명이다. NULL일 경우 경로에 있는 모든 파일을 읽는다. 마지막 파라메터는 오프셋이며 유일한 숫자값이다. 이전에 읽은 마지막 파일의 오프셋이다. 이 값이 지정되면 그 이후번째의 파일부터 읽는다.

 쿼리는 각각의 이벤트를 한개의 로우로 리턴한다. 이벤트에 대한 데이터는 event_data란 XML 컬럼에 저장된다. XQuery를 사용하여 바로 데이터를 읽을 수 있다. 일단 한번 실행하면 조회하거나 정렬또는 집계할 수 있다. 이제부터 완전한 예제를 보여줄 것이다.

- ### a. 고비용 쿼리 식별
    SQL Server의 목적은 가장 짧은시간에 결과셋을 리턴하는 것이다. 이렇게 하기 위해서는 SQL Server는 쿼리 최적화기라고 불리우는 비용기반 최적화기가 내장되어 있다. 쿼리실행계획이라 부르는 비용효율 전략을 생성한다. 쿼리 최적화 프로그램은 쿼리를 실행하는 데 필요한 CPU, 메모리 및 디스크 I/O 사용량을 포함하여(이에 국한되지 않음) 많은 요인에 가중치를 둡니다. 이런 모든 요소들은 인덱스에 의해 유지되는 데이터 또는 실실간으로 생성되는 통계, 데이터의 제약조건, 몇가지 시스템의 지식등에 대한 통계와 같은 다양한 소스들로부터 유발되는데 다중CPU와 대량의 메모리와 같은 상황에서 실행된다. 이런 모든 요소들에서 옵티마이저는 비용 효율적 실행계획을 생성한다.

    세션에서 리턴되는 데이터에서 cpu_time과 logical_reads, physical_reads 필드는 역시 쿼리의 어느부분에서 비용이 발생하는지 보여준다. cpu_time필드는 쿼리를 실행하기 위해서 사용되는 CPU시간을 대표한다. logical_reads와 physical_reads 필드들은 페이지(8KB크기)의 숫자를 나타내는데 쿼리에의해 발생하는 메모리 I/O 스트레스의 양을 지칭한다. 그들은 역시 디스크 스트레스를 지칭하는데 작업 쿼리의 경우 메모리 페이지를 백업하기 하거나 첫번째 데이터 접근의 경우 디스크에서 메모리로 데이터가 채워지는 경우 또는 메모리 병목동안 디스크로 옮겨져야 하므로 디스크 스트레스를 나타낸다. 쿼리의 논리적 읽기가 많아질수록 디스크의 스트레스가 더 높아질수 있다. 과도한 수의 논리적 페이지들은 CPU가 관리하는 비용도 증가시키기 CPU로드도 증가시킨다. 이것은 자동 상관관계가 아니다. 가장큰수의 읽기 쿼리가 가장 큰 부하를 발생시키는 쿼리가 항상은 아니다. 그러나 일반적으로 좋은 첫번째 대상이기는 하다. I/O의 수를 최소화시키는것이 비용효율계획의 필요조건은 아니지만 I/O연산은 비용이 많이 드는 작업이기 때문에 가장 적은 비용의 실행계획이 가장 적은 I/O를 가지는 경우가 많다.

    대량의 논리적 읽기를 유발하는 쿼리들은 항상 대량의 데이터 셋때문에 많은 잠금을 보유하게 된다. 읽기 연산은 데이터에 공유잠금을 얻지만 격리레벨에 따라 달라진다. 이런 쿼리들은 데이터를 수정하는 쿼리들을 차단하는 블로킹을 자주 유발한다. 또한 고비용이 되며 장기간 실행쿼리가 되기에 장기간 다른 쿼리들을 차단한다. 차단되는 쿼리들은 또한 다른 쿼리들을 차단할수 있는데 뒤에서 블로킹 체인에 대해 소개할 것이다.

    결과적으로 비용이 많이 드는 쿼리를 식별하고 먼저 최적화하여 다음을 수행하는 것이 합리적입니다.

        * 고비용 쿼리의 성능을 향상시키기
        * 시스템 자원에서 모든 스트레스 줄이기
        * 데이터베이스 블로킹 줄이기

    고비용 쿼리는 아래의 두가지 타입으로 분류할 수 있다.

        * 단일 실행 : 각각의 실행이 고비용일 경우
        * 다중 실행 : 각각의 쿼리는 고비용이 아니지만 해당 쿼리의 반복적인 실행이 결국 시스템 자원에 압박을 유발할 때

    우리는 다른 접근 방식을 사용하여 이런 두가지 종류의 고비용 쿼리를     식별할 수 있다. 

- ### b. 단일 실행에서 고비용 쿼리
    세션의 결과파일과 쿼리 저장소 또는 sys.dm_exec_query_stats을 분석하여 고비용 쿼리를 식별해 낼수 있다. 예를 들면 대량의 논리적 읽기를 유발하는 쿼리를 식별해려면 logical_reads 순으로 정렬하여 ㅏㅎㄹ수 있다. duration이나 CPU 또는 이런 요소들을 결합하여 사용할 수도 있다. 다음 스템으로 세션 정보에 접근할 수 있다.

    1. 워크로드 포함한 세션 캡처
    2. 파일로 세션결과 저장
    3. .xel파일을 SSMS로 열기
    4. 또는 logical_reads 순으로 정렬하기

        ```sql
        WITH xEvents
        AS
        (
            SELECT object_name AS xEventName,
                CAST(event_data AS XML) AS xEventData
            FROM sys.fn_xe_file_target_read_file('C:\Sessions\QueryPerformanceMetrics*.xel',NULL, NULL, NULL)
        )
        SELECT xEventName,
            xEventData.value('(/event/data[@name="duration"]/value)[1]',    'bigint') Duration,
            xEventData.value('(/event/data[@name="physical_reads"]/value)[1]', 'bigint') PhysicalReads,
            xEventData.value('(/event/data[@name="logical_reads"]/value)[1]', 'bigint') LogicalReads,
            xEventData.value('(/event/data[@name="cpu_time"]/value)[1]', 'bigint') CpuTime,
            CASE xEventName
                WHEN 'sql_batch_completed'  THEN xEventData.value('(/event/data[@name="batch_text"]/value)[1]', 'varchar(max)')
                WHEN 'rpc_completed'        THEN xEventData.value('(/event/data[@name="statement"]/value)[1]', 'varchar(max)')
            END AS SQLText,
            xEventData.value('(/event/data[@name="query_hash"]/value)[1]', 'binary(8)') QueryHash
        INTO Session_Table
        FROM xEvents;
        SELECT st.xEventName,
            st.Duration,
            st.PhysicalReads,
            st.LogicalReads,
            st.CpuTime,
            st.SQLText,
            st.QueryHash
        FROM Session_Table AS st
        ORDER BY st.LogicalReads DESC;
        ```

        위에서부터 살펴보자, 첫째로 CTE로 xevent결과를 만들었고 event_data라는 컬럼을 XML로 변경시켰다. 그다음 CTE결과를 XQuery로 좀더 직관적이게 다듬었다.
        CTE를 만들때 xel파일 경로에 * 를 사용하여 해당 위치에 해당하는 모든 파일을 읽도록 하였다. 그 이후 논리적 읽기가 많은 쿼리 순으로 정렬하여 테이블 Session_Table에 저장하였다.

        수집된 양에 따라 xel파일을 매번 읽고 변환하는 작업이 오래 걸릴 것이다. 그런 경우 sys.fn_xe_file_target_read_file의 결과를 테이블로 저장해 놓으면 그 다음부터는 좀더 효율적으로 조회를 할 수 있다. 결과테이블에 
        인덱스를 걸수도 있다고 다양한 T-SQL 함수를 적용할 수도 있다. 

        몇가지 경우 시스템모니터 결과에 CPU상에 큰 스트레스를 볼수 있다. 이런 종류의 작업은 저장프로시저 재컴파일, 집계함수, 데이터 정렬, 해시조인등가 비슷한 CPU위주의 작업들이다. 그런 경우 cpu_time 필드로 정렬하여 가장 큰 cpu부하가 발생하는 쿼리를 실벽할수 있다.


